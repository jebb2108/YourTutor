import asyncio
import logging
import sys
import sqlite3
import os
from typing import List, Tuple, Optional

# –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã aiogram –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Telegram API
from aiogram import Bot, Dispatcher, F  # F - —Ñ–∏–ª—å—Ç—Ä—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode  # –†–µ–∂–∏–º—ã —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞
from aiogram.filters import Command, CommandStart  # –§–∏–ª—å—Ç—Ä—ã –∫–æ–º–∞–Ω–¥
from aiogram.fsm.context import FSMContext  # –ö–æ–Ω—Ç–µ–∫—Å—Ç –º–∞—à–∏–Ω—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π
from aiogram.fsm.state import State, StatesGroup, default_state  # –°–∏—Å—Ç–µ–º–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π
from aiogram.fsm.storage.memory import MemoryStorage  # –•—Ä–∞–Ω–∏–ª–∏—â–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π –≤ –ø–∞–º—è—Ç–∏
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton  # –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö Telegram

# –ò–º–ø–æ—Ä—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (—Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –∏ —Å–æ–æ–±—â–µ–Ω–∏—è)
from messages import *

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
TOKEN = KEY  # –°–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á –∏–∑ —Ñ–∞–π–ª–∞ messages.py
storage = MemoryStorage()  # –•—Ä–∞–Ω–∏–ª–∏—â–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π (–≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ–π –ø–∞–º—è—Ç–∏)
dp = Dispatcher(storage=storage)  # –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –¥–∏—Å–ø–µ—Ç—á–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π

"""
–ö–ª–∞—Å—Å—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π (Finite State Machine):
–ö–∞–∫ —Å—Ü–µ–Ω–∞—Ä–∏–π –≤ –∏–≥—Ä–µ - –∑–∞–ø–æ–º–∏–Ω–∞—é—Ç –≥–¥–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è.
–ù–∞–ø—Ä–∏–º–µ—Ä: 
1. –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ -> 2. –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤–∞ -> 3. –í—ã–±–æ—Ä —á–∞—Å—Ç–∏ —Ä–µ—á–∏

StatesGroup - –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –¥–ª—è —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π
"""


class WordStates(StatesGroup):
    """–°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞"""
    waiting_for_part_of_speech = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –≤—ã–±–æ—Ä–∞ —á–∞—Å—Ç–∏ —Ä–µ—á–∏


class WordsViewState(StatesGroup):
    """–°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å–ª–æ–≤–∞—Ä—è"""
    viewing_words = State()  # –†–µ–∂–∏–º –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å–ª–æ–≤


class EditState(StatesGroup):
    """–°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–ª–æ–≤"""
    waiting_edit_word = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞
    waiting_edit_pos = State()  # –û–∂–∏–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏ —Ä–µ—á–∏
    waiting_edit_value = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è


"""
–†–∞–±–æ—Ç–∞ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö:
–ö–∞–∂–¥—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ö—Ä–∞–Ω–∏—Ç —Å–ª–æ–≤–∞ –≤ —Å–≤–æ–µ–π SQLite –±–∞–∑–µ.
–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É: dbs/dictionary_12345.db (–≥–¥–µ 12345 - ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)

–ü—Ä–∏–Ω—Ü–∏–ø —Ä–∞–±–æ—Ç—ã:
1. –ü—Ä–∏ –ø–µ—Ä–≤–æ–º –æ–±—Ä–∞—â–µ–Ω–∏–∏ —Å–æ–∑–¥–∞–µ—Ç—Å—è —Ñ–∞–π–ª –ë–î
2. –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è—Ö
3. –î–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (SQLite –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—å)
"""


def get_user_db_path(user_id: int) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—É—Ç—å –∫ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–æ–π –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    return f'dbs/dictionary_{user_id}.db'


def ensure_user_db(user_id: int):
    """–°–æ–∑–¥–∞–µ—Ç –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –∏ —Ç–∞–±–ª–∏—Ü—É –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –æ–±—Ä–∞—â–µ–Ω–∏–∏"""
    db_path = get_user_db_path(user_id)
    if not os.path.exists(db_path):
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute(CREATE_TABLE)  # SQL-–∑–∞–ø—Ä–æ—Å –∏–∑ messages.py
        conn.commit()
        conn.close()
        logging.info(f"Created new database for user {user_id}")


async def get_words_from_db(user_id: int) -> List[Tuple[str, str, str]]:
    """–ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ —Å–ª–æ–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±–µ—Ä—Ç–∫–∞)"""
    ensure_user_db(user_id)
    db_path = get_user_db_path(user_id)
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    try:
        cursor.execute("SELECT word, part_of_speech, translation FROM words ORDER BY word")
        return cursor.fetchall()  # –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π (—Å–ª–æ–≤–æ, —á–∞—Å—Ç—å_—Ä–µ—á–∏, –ø–µ—Ä–µ–≤–æ–¥)
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        return []
    finally:
        conn.close()


async def delete_word_from_db(user_id: int, word: str) -> bool:
    """–£–¥–∞–ª—è–µ—Ç —Å–ª–æ–≤–æ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    ensure_user_db(user_id)
    db_path = get_user_db_path(user_id)
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    try:
        cursor.execute("DELETE FROM words WHERE word = ?", (word,))
        conn.commit()
        return cursor.rowcount > 0  # True –µ—Å–ª–∏ —É–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–æ—à–ª–æ —É—Å–ø–µ—à–Ω–æ
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        return False
    finally:
        conn.close()


async def update_word_in_db(user_id: int, old_word: str, new_word: str, pos: str, value: str) -> bool:
    """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å–ª–æ–≤–æ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö (—Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–ª–æ–≤–∞)"""
    ensure_user_db(user_id)
    db_path = get_user_db_path(user_id)
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    try:
        if old_word != new_word:
            # –ï—Å–ª–∏ —Å–ª–æ–≤–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å - —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
            cursor.execute("DELETE FROM words WHERE word = ?", (old_word,))
            cursor.execute("""
                INSERT INTO words (word, part_of_speech, translation)
                VALUES (?, ?, ?)
            """, (new_word, pos, value))
        else:
            # –ï—Å–ª–∏ —Å–ª–æ–≤–æ –Ω–µ –º–µ–Ω—è–ª–æ—Å—å - –æ–±–Ω–æ–≤–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª—è
            cursor.execute("""
                UPDATE words 
                SET part_of_speech = ?, translation = ?
                WHERE word = ?
            """, (pos, value, new_word))
        conn.commit()
        return cursor.rowcount > 0
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        return False
    finally:
        conn.close()


async def add_word_to_db(user_id: int, word: str, pos: str, value: str) -> bool:
    """–î–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤–æ–µ —Å–ª–æ–≤–æ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    ensure_user_db(user_id)
    db_path = get_user_db_path(user_id)
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    try:
        cursor.execute(INSERT_WORD, (word, pos, value))  # INSERT_WORD –∏–∑ messages.py
        conn.commit()
        return cursor.rowcount > 0
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        return False
    finally:
        conn.close()


async def check_word_exists(user_id: int, word: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Å–ª–æ–≤–æ –≤ –±–∞–∑–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    ensure_user_db(user_id)
    db_path = get_user_db_path(user_id)
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    try:
        cursor.execute(SELECT_WORD, (word,))  # SELECT_WORD –∏–∑ messages.py
        return cursor.fetchone() is not None
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        return False
    finally:
        conn.close()


"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π:
–°–µ—Ä–¥—Ü–µ –±–æ—Ç–∞ - —Ñ—É–Ω–∫—Ü–∏–∏, —Ä–µ–∞–≥–∏—Ä—É—é—â–∏–µ –Ω–∞ –¥–µ–π—Å—Ç–≤–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.

–ü—Ä–∏–Ω—Ü–∏–ø —Ä–∞–±–æ—Ç—ã:
1. Telegram —Å–µ—Ä–≤–µ—Ä –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–±—ã—Ç–∏–µ (—Å–æ–æ–±—â–µ–Ω–∏–µ, –Ω–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏)
2. –î–∏—Å–ø–µ—Ç—á–µ—Ä (dp) –Ω–∞—Ö–æ–¥–∏—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
3. –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è (–∫–æ—Ä—É—Ç–∏–Ω–∞)
4. –ë–æ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ—Ç–≤–µ—Ç

–ö–ª—é—á–µ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä–æ–≤:
- @dp.message(Command("words")): —Ä–µ–∞–≥–∏—Ä—É–µ—Ç –Ω–∞ –∫–æ–º–∞–Ω–¥—É /words
- @dp.callback_query(F.data == ...): –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏
"""


@dp.message(Command("words"))
async def show_dictionary(message: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /words - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    user_id = message.from_user.id
    words = await get_words_from_db(user_id)

    if not words:
        await message.answer("üì≠ Your dictionary is empty. Add some words first!")
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ª–æ–≤–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    await state.update_data(
        words=words,
        current_index=0,
        current_letter=words[0][0][0].upper() if words[0][0] else 'A'
    )

    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ
    await show_current_word(message, state)
    await state.set_state(WordsViewState.viewing_words)


async def show_current_word(message: Message, state: FSMContext, edit: bool = False):
    """
    –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ —Å–ª–æ–≤–æ —Å –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π

    –ü–∞—Ä–∞–º–µ—Ç—Ä edit –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç:
    - False: –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    - True: —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    """
    data = await state.get_data()
    words = data.get("words", [])
    current_index = data.get("current_index", 0)

    if not words or current_index >= len(words):
        await message.answer("‚ùå No words found")
        await state.clear()
        return

    word, pos, value = words[current_index]

    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å HTML-—Ä–∞–∑–º–µ—Ç–∫–æ–π
    text = (
        f"üìñ <b>Word</b>: {word}{' ' * (70 - len(word))}{current_index + 1} out of {len(words)} üî¢\n"
        f"üî§ <b>Part of speech:</b> {pos}\n"
    )
    if value:
        text += f"üí° <b>Meaning:</b> {value[:50]+'...' if len(value) > 50 else value}\n"

    # –°–æ–∑–¥–∞–µ–º –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –¥–µ–π—Å—Ç–≤–∏—è–º–∏
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Info", callback_data="show_info")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data="prev_word"),
         InlineKeyboardButton(text="‚û°Ô∏è", callback_data="next_word")],
        [InlineKeyboardButton(text="‚¨ÜÔ∏è Letter", callback_data="prev_letter"),
         InlineKeyboardButton(text="Letter ‚¨áÔ∏è", callback_data="next_letter")],
        [InlineKeyboardButton(text="‚úèÔ∏è Edit", callback_data="edit_word"),
         InlineKeyboardButton(text="üóëÔ∏è Delete", callback_data="delete_word")],
        [InlineKeyboardButton(text="‚ùå Cancel", callback_data="cancel_words")]
    ])

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–ª–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    if edit:
        await message.edit_text(text, reply_markup=keyboard, parse_mode=ParseMode.HTML)
    else:
        await message.answer(text, reply_markup=keyboard, parse_mode=ParseMode.HTML)


"""
–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –∫–Ω–æ–ø–æ–∫:
–ö–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∏–º–∞–µ—Ç inline-–∫–Ω–æ–ø–∫—É, Telegram –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç CallbackQuery

–ü—Ä–∏–Ω—Ü–∏–ø —Ä–∞–±–æ—Ç—ã:
1. –ö–Ω–æ–ø–∫–∞ —Å–æ–∑–¥–∞–µ—Ç—Å—è —Å callback_data="–¥–µ–π—Å—Ç–≤–∏–µ"
2. –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç—Å—è —á–µ—Ä–µ–∑ @dp.callback_query(F.data == "–¥–µ–π—Å—Ç–≤–∏–µ")
3. –í –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ:
   - –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
   - –ú–µ–Ω—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
   - –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback (callback.answer())
"""


@dp.callback_query(F.data == "prev_word", WordsViewState.viewing_words)
async def prev_word_handler(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ '–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–ª–æ–≤–æ'"""
    data = await state.get_data()
    current_index = data.get("current_index", 0)

    if current_index > 0:
        await state.update_data(current_index=current_index - 1)
        await show_current_word(callback.message, state, edit=True)
    else:
        await callback.answer("You're at the first word")

    await callback.answer()  # –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É


@dp.callback_query(F.data == "next_word", WordsViewState.viewing_words)
async def next_word_handler(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ '–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ'"""
    data = await state.get_data()
    words = data.get("words", [])
    current_index = data.get("current_index", 0)

    if current_index < len(words) - 1:
        await state.update_data(current_index=current_index + 1)
        await show_current_word(callback.message, state, edit=True)
    else:
        await callback.answer("You're at the last word")

    await callback.answer()


@dp.callback_query(F.data == "prev_letter", WordsViewState.viewing_words)
async def prev_letter_handler(callback: CallbackQuery, state: FSMContext):
    """–ü–µ—Ä–µ—Ö–æ–¥ –∫ –ø–µ—Ä–≤–æ–π –±—É–∫–≤–µ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥—Ä—É–ø–ø–µ —Å–ª–æ–≤"""
    data = await state.get_data()
    words = data.get("words", [])
    current_index = data.get("current_index", 0)
    current_letter = data.get("current_letter", 'A')

    # –ü–æ–ª—É—á–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –±—É–∫–≤—ã –∏–∑ —Å–ª–æ–≤
    letters = sorted(set(word[0][0].upper() for word in words if word[0] and len(word[0]) > 0))

    if not letters:
        await callback.answer("No letters found")
        return

    # –ù–∞—Ö–æ–¥–∏–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é –±—É–∫–≤—ã –≤ –∞–ª—Ñ–∞–≤–∏—Ç–µ
    try:
        current_pos = letters.index(current_letter)
        new_pos = max(0, current_pos - 1)
        new_letter = letters[new_pos]
    except ValueError:
        new_letter = letters[0]

    # –ò—â–µ–º –ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ –Ω–∞ –Ω–æ–≤—É—é –±—É–∫–≤—É
    new_index = next((i for i, word in enumerate(words)
                      if word[0] and word[0][0].upper() == new_letter), 0)

    await state.update_data(
        current_index=new_index,
        current_letter=new_letter
    )
    await show_current_word(callback.message, state, edit=True)
    await callback.answer()


@dp.callback_query(F.data == "next_letter", WordsViewState.viewing_words)
async def next_letter_handler(callback: CallbackQuery, state: FSMContext):
    """–ü–µ—Ä–µ—Ö–æ–¥ –∫ –ø–µ—Ä–≤–æ–π –±—É–∫–≤–µ –≤ —Å–ª–µ–¥—É—é—â–µ–π –≥—Ä—É–ø–ø–µ —Å–ª–æ–≤"""
    data = await state.get_data()
    words = data.get("words", [])
    current_index = data.get("current_index", 0)
    current_letter = data.get("current_letter", 'A')

    # –ü–æ–ª—É—á–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –±—É–∫–≤—ã –∏–∑ —Å–ª–æ–≤
    letters = sorted(set(word[0][0].upper() for word in words if word[0] and len(word[0]) > 0))

    if not letters:
        await callback.answer("No letters found")
        return

    # –ù–∞—Ö–æ–¥–∏–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é –±—É–∫–≤—ã –≤ –∞–ª—Ñ–∞–≤–∏—Ç–µ
    try:
        current_pos = letters.index(current_letter)
        new_pos = min(len(letters) - 1, current_pos + 1)
        new_letter = letters[new_pos]
    except ValueError:
        new_letter = letters[-1]

    # –ò—â–µ–º –ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ –Ω–∞ –Ω–æ–≤—É—é –±—É–∫–≤—É
    new_index = next((i for i, word in enumerate(words)
                      if word[0] and word[0][0].upper() == new_letter), 0)

    await state.update_data(
        current_index=new_index,
        current_letter=new_letter
    )
    await show_current_word(callback.message, state, edit=True)
    await callback.answer()


@dp.callback_query(F.data == "cancel_words", WordsViewState.viewing_words)
async def cancel_words_handler(callback: CallbackQuery, state: FSMContext):
    """–í—ã—Ö–æ–¥ –∏–∑ —Ä–µ–∂–∏–º–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å–ª–æ–≤"""
    await callback.message.delete()  # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π
    await state.clear()  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    await callback.answer()


@dp.callback_query(F.data == "delete_word", WordsViewState.viewing_words)
async def delete_word_handler(callback: CallbackQuery, state: FSMContext):
    """–£–¥–∞–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ —Å–ª–æ–≤–∞ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    user_id = callback.from_user.id
    data = await state.get_data()
    words = data.get("words", [])
    current_index = data.get("current_index", 0)

    if not words or current_index >= len(words):
        await callback.answer("No word to delete")
        return

    word, _, _ = words[current_index]

    # –£–¥–∞–ª—è–µ–º —Å–ª–æ–≤–æ –∏–∑ –±–∞–∑—ã
    if await delete_word_from_db(user_id, word):
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤
        words = await get_words_from_db(user_id)

        if not words:
            # –ï—Å–ª–∏ —Å–ª–æ–≤–∞—Ä—å –ø—É—Å—Ç - –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ä–µ–∂–∏–º–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞
            await callback.message.edit_text("‚úÖ Word deleted\n")
            await state.clear()
            return

        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω–¥–µ–∫—Å
        new_index = current_index if current_index < len(words) else len(words) - 1
        new_letter = words[new_index][0][0].upper() if words[new_index][0] else 'A'

        await state.update_data(
            words=words,
            current_index=new_index,
            current_letter=new_letter
        )

        # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        await show_current_word(callback.message, state, edit=True)
        await callback.answer(f"‚úÖ {word} deleted")
    else:
        await callback.answer(f"‚ùå Failed to delete {word}")


@dp.callback_query(F.data == "edit_word", WordsViewState.viewing_words)
async def start_edit_word(callback: CallbackQuery, state: FSMContext):
    """–ù–∞—á–∞–ª–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–ª–æ–≤–∞"""
    data = await state.get_data()
    words = data.get("words", [])
    current_index = data.get("current_index", 0)

    if not words or current_index >= len(words):
        await callback.answer("No word to edit")
        return

    word, pos, value = words[current_index]

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
    await state.update_data(
        editing_word=word,
        editing_pos=pos,
        editing_value=value,
        editing_index=current_index,
        original_word=word,
        original_pos=pos,
        original_value=value
    )

    # –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≤—ã–±–æ—Ä–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ–≥–æ –ø–æ–ª—è
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="‚úèÔ∏è Word", callback_data="edit_word_text"),
            InlineKeyboardButton(text="üí° Meaning", callback_data="edit_word_value")
        ],
        [
            InlineKeyboardButton(text="üî§ Part of Speech", callback_data="edit_word_pos")
        ],
        [InlineKeyboardButton(text="‚Ü©Ô∏è Back", callback_data="cancel_edit")]
    ])

    await callback.message.edit_text(
        f"‚úèÔ∏è <b>Editing:</b> {word}\n"
        f"üî§ <b>Current POS:</b> {pos}\n"
        f"üí° <b>Current Meaning:</b> {value or 'None'}\n\n"
        "Select what to edit:",
        reply_markup=keyboard,
        parse_mode=ParseMode.HTML
    )
    await state.set_state(EditState.waiting_edit_word)


@dp.callback_query(F.data.startswith("edit_word_"), EditState.waiting_edit_word)
async def handle_edit_choice(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –ø–æ–ª—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è"""
    edit_type = callback.data.replace("edit_word_", "")
    data = await state.get_data()
    word = data.get("editing_word", "")

    if edit_type == "text":
        await callback.message.edit_text(f"‚úèÔ∏è Enter new text for <b>{word}</b>:", parse_mode=ParseMode.HTML)
        await state.set_state(EditState.waiting_edit_word)
    elif edit_type == "value":
        await callback.message.edit_text(f"üí° Enter new meaning for <b>{word}</b>:", parse_mode=ParseMode.HTML)
        await state.set_state(EditState.waiting_edit_value)
    elif edit_type == "pos":
        # –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –≤—ã–±–æ—Ä–æ–º —á–∞—Å—Ç–∏ —Ä–µ—á–∏
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Noun", callback_data="newpos_noun"),
             InlineKeyboardButton(text="Verb", callback_data="newpos_verb")],
            [InlineKeyboardButton(text="Adjective", callback_data="newpos_adjective"),
             InlineKeyboardButton(text="Adverb", callback_data="newpos_adverb")],
            [InlineKeyboardButton(text="‚Ü©Ô∏è Back", callback_data="cancel_edit")]
        ])
        await callback.message.edit_text(f"üî§ Select new part of speech for <b>{word}</b>:",
                                         reply_markup=keyboard,
                                         parse_mode=ParseMode.HTML)
        await state.set_state(EditState.waiting_edit_pos)

    await callback.answer()


@dp.callback_query(F.data == "cancel_edit", EditState.waiting_edit_word)
@dp.callback_query(F.data == "cancel_edit", EditState.waiting_edit_value)
@dp.callback_query(F.data == "cancel_edit", EditState.waiting_edit_pos)
async def cancel_edit_handler(callback: CallbackQuery, state: FSMContext):
    """–û—Ç–º–µ–Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –≤–æ–∑–≤—Ä–∞—Ç –∫ –ø—Ä–æ—Å–º–æ—Ç—Ä—É"""
    await state.set_state(WordsViewState.viewing_words)
    await show_current_word(callback.message, state, edit=True)
    await callback.answer()


@dp.message(EditState.waiting_edit_word)
async def handle_edit_word_text(message: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ —Å–ª–æ–≤–∞"""
    user_id = message.from_user.id
    new_word = message.text.strip()
    data = await state.get_data()
    old_word = data.get("editing_word", "")
    original_word = data.get("original_word", "")

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã (–µ—Å–ª–∏ —Å–ª–æ–≤–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å)
    if new_word != original_word:
        words = await get_words_from_db(user_id)
        if any(w[0].lower() == new_word.lower() for w in words):
            await message.answer("‚ö†Ô∏è This word already exists in the dictionary")
            return

    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º
    await state.update_data(editing_word=new_word)
    await save_edited_word(message, state, user_id)


@dp.message(EditState.waiting_edit_value)
async def handle_edit_word_value(message: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —Å–ª–æ–≤–∞"""
    new_value = message.text.strip()
    await state.update_data(editing_value=new_value)
    await save_edited_word(message, state, message.from_user.id)


@dp.callback_query(F.data.startswith("newpos_"), EditState.waiting_edit_pos)
async def handle_edit_word_pos(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –Ω–æ–≤–æ–π —á–∞—Å—Ç–∏ —Ä–µ—á–∏"""
    new_pos = callback.data.replace("newpos_", "")
    await state.update_data(editing_pos=new_pos)
    await save_edited_word(callback.message, state, callback.from_user.id)
    await callback.answer()


async def save_edited_word(message: Message, state: FSMContext, user_id: int):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å–ª–æ–≤–∞ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"""
    data = await state.get_data()
    # –¢–µ–∫—É—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    new_word = data.get("editing_word", "")
    new_pos = data.get("editing_pos", "")
    new_value = data.get("editing_value", "")

    # –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è (–¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è)
    original_word = data.get("original_word", "")
    original_pos = data.get("original_pos", "")
    original_value = data.get("original_value", "")

    editing_index = data.get("editing_index", 0)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    if (new_word == original_word and
            new_pos == original_pos and
            new_value == original_value):
        await message.answer("‚ÑπÔ∏è No changes detected")
        await state.set_state(WordsViewState.viewing_words)
        await show_current_word(message, state, edit=True)
        return

    # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–æ–≤–æ –≤ –±–∞–∑–µ
    success = await update_word_in_db(user_id, original_word, new_word, new_pos, new_value)
    if success:
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤
        words = await get_words_from_db(user_id)

        # –ù–∞—Ö–æ–¥–∏–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é —Å–ª–æ–≤–∞
        new_index = next((i for i, w in enumerate(words) if w[0] == new_word), editing_index)

        await state.update_data(
            words=words,
            current_index=new_index
        )

        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –ø—Ä–æ—Å–º–æ—Ç—Ä—É
        await state.set_state(WordsViewState.viewing_words)
        await show_current_word(message, state, edit=True)
    else:
        await message.answer("‚ùå Failed to update word")
        await state.set_state(WordsViewState.viewing_words)
        await show_current_word(message, state, edit=True)

    """
    –ü—Ä–æ—Ü–µ—Å—Å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö —Å–ª–æ–≤:
    1. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–ª–æ–≤–æ (–∏–ª–∏ —Å–ª–æ–≤–æ:–∑–Ω–∞—á–µ–Ω–∏–µ)
    2. –ë–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∏—Ç –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è —á–∞—Å—Ç–∏ —Ä–µ—á–∏
    3. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±–∏—Ä–∞–µ—Ç —á–∞—Å—Ç—å —Ä–µ—á–∏
    4. –ë–æ—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–ª–æ–≤–æ –≤ –ë–î
    
    FSMContext - –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è, —Ö—Ä–∞–Ω—è—â–∏–π –¥–∞–Ω–Ω—ã–µ –º–µ–∂–¥—É —à–∞–≥–∞–º–∏
    """

@ dp.message(CommandStart())
async def start_command_handler(message: Message):

    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start - –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ"""
    await message.answer(f"üëã Hello, {message.from_user.first_name}! {GREETING}", parse_mode=ParseMode.HTML)

@dp.message(WordStates.waiting_for_part_of_speech)
async def handle_part_of_speech_text(message: Message):
    """–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫–∏ –ø—Ä–∏ –≤–≤–æ–¥–µ —Ç–µ–∫—Å—Ç–∞ –≤–º–µ—Å—Ç–æ –≤—ã–±–æ—Ä–∞ —á–∞—Å—Ç–∏ —Ä–µ—á–∏"""
    await message.answer("‚ö†Ô∏è Please select a part of speech from the buttons above")

@dp.callback_query(F.data.startswith("pos_"), WordStates.waiting_for_part_of_speech)
async def save_new_word_handler(callback: CallbackQuery, state: FSMContext) -> None:
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ —á–∞—Å—Ç–∏ —Ä–µ—á–∏"""
    user_id = callback.from_user.id
    part_of_speech = callback.data.replace("pos_", "")
    data = await state.get_data()
    word = data.get("word")
    value = data.get("value")

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
    if await add_word_to_db(user_id, word, part_of_speech, value):
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ
        response = f"‚úÖ Saved: {word} ({part_of_speech})"
        if value:
            response += f"\nMeaning: {value[:50] + '...' if len(value) > 50 else value}"

        await callback.message.edit_text(response)
        await callback.answer()
        await state.clear()  # –í—ã—Ö–æ–¥–∏–º –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    else:
        await callback.message.edit_text("‚ùå Failed to save word")
        await callback.answer()

@dp.message()
async def universal_message_handler(message: Message, state: FSMContext):
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π

    –õ–æ–≥–∏–∫–∞ —Ä–∞–±–æ—Ç—ã:
    1. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—ã (–æ–Ω–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ)
    2. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    3. –í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è:
       - –ï—Å–ª–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å–ª–æ–≤–∞: –ø—Ä–æ—Å–∏–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫–∏
       - –ï—Å–ª–∏ –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
       - –ò–Ω–∞—á–µ: –Ω–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞
    """
    # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã
    if message.text.startswith('/'):
        return

    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    current_state = await state.get_state()

    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –≤—ã–±—Ä–∞—Ç—å —á–∞—Å—Ç—å —Ä–µ—á–∏
    if current_state == WordStates.waiting_for_part_of_speech.state:
        await handle_part_of_speech_text(message)
        return

    # –ï—Å–ª–∏ –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
    if current_state in [
        EditState.waiting_edit_word.state,
        EditState.waiting_edit_pos.state,
        EditState.waiting_edit_value.state
    ]:
        return

    # –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞
    await process_word_input(message, state)

async def process_word_input(message: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –Ω–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞"""
    user_id = message.from_user.id
    text = message.text.strip()

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç "—Å–ª–æ–≤–æ:–∑–Ω–∞—á–µ–Ω–∏–µ"
    if ':' in text:
        parts = text.split(':', 1)
        word = parts[0].strip()
        value = parts[1].strip() if parts[1].strip() else None
    else:
        word, value = text, None

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
    if await check_word_exists(user_id, word):
        await message.answer("‚ö†Ô∏è Word already exists")
        await state.clear()
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(word=word, value=value)

    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å —á–∞—Å—Ç—è–º–∏ —Ä–µ—á–∏
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Noun", callback_data="pos_noun"),
         InlineKeyboardButton(text="Verb", callback_data="pos_verb")],
        [InlineKeyboardButton(text="Adjective", callback_data="pos_adjective"),
         InlineKeyboardButton(text="Adverb", callback_data="pos_adverb")]
    ])

    # –ü–µ—Ä–µ–≤–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤—ã–±–æ—Ä–∞ —á–∞—Å—Ç–∏ —Ä–µ—á–∏
    await message.answer("‚ùì What part of speech is it?", reply_markup=keyboard)
    await state.set_state(WordStates.waiting_for_part_of_speech)

"""
–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞:
asyncio.run() - –∑–∞–ø—É—Å–∫–∞–µ—Ç –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é —Å—Ä–µ–¥—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
bot.start_polling() - –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –æ–ø—Ä–æ—Å–∞ —Å–µ—Ä–≤–µ—Ä–æ–≤ Telegram

–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:
1. –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞
2. –ó–∞–ø—É—Å–∫–∞–µ–º –¥–∏—Å–ø–µ—Ç—á–µ—Ä –≤ —Ä–µ–∂–∏–º–µ –æ–ø—Ä–æ—Å–∞
3. –ë–æ—Ç –Ω–∞—á–∏–Ω–∞–µ—Ç –ø–æ–ª—É—á–∞—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –æ—Ç —Å–µ—Ä–≤–µ—Ä–æ–≤ Telegram
4. –ö–∞–∂–¥–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –∑–∞–¥–∞—á–µ
"""

async def main() -> None:
    """–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –≤ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"""
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ —Å HTML-—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))

    # –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
    await dp.start_polling(bot)

if __name__ == "__main__":
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    logging.basicConfig(
        level=logging.INFO,
        stream=sys.stdout,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s"
    )

    # –ó–∞–ø—É—Å–∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    asyncio.run(main())